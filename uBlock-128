#pragma region  clearspace
#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
unsigned oldda_step2, oldxiao_step;
unsigned long long Step2_Big_Num;
unsigned char step2_match[16];
unsigned long long Temp_duibi2;
unsigned long long step2_youbiao;
unsigned int NOW_ISTIME_CLOSE;
unsigned int sbox[16] = { 0x7,0x4,0x9,0xc,0xb,0xa,0xd,0x8,0xf,0xe,0x1,0x6,0x0,0x3,0x2,0x5 };
unsigned int isbox[16];
unsigned long long oldda, oldxiao;
unsigned int isboxdiff[16][16];
unsigned long long tempduibi;
//unsigned char qianliang[100000000][32];
unsigned char tstate[16];
int tempindex = 0;
unsigned char Alpha_pashalf8[8];
unsigned char Alpha_firhalf8[8];
unsigned First_NUM;
unsigned Second_NUM;

void FINAL_step();

void Select_First_Step_two_detail(int Begin_Index, int Tail_Index);
void Select_First_Step_final_detail(int Begin_Index, int Tail_Index);



void Select_First_Step_two();
unsigned long long can_go_alpha = 0;
unsigned long long can_go_beta2 = 0;

unsigned long long Now_Big_Num;
void caozuo(unsigned char* t1state)
{
	for (int i = 0; i < 16; i++)
	{
		tstate[i] = t1state[i];
	}


	for (int i = 0; i < 8; i++)
	{
		tstate[i + 8] ^= tstate[i];
	}

	for (int i = 0; i < 8; i++)
	{
		if (i < 7)
			tstate[i] ^= tstate[9 + i];
		else
			tstate[i] ^= tstate[1 + i];
	}


	for (int i = 0; i < 8; i++)
	{
		if (i < 6)
			tstate[i + 8] ^= tstate[2 + i];
		else
			tstate[i + 8] ^= tstate[i - 6];
	}

	for (int i = 0; i < 8; i++)
	{
		if (i < 6)
			tstate[i] ^= tstate[10 + i];
		else
			tstate[i] ^= tstate[2 + i];
	}


	for (int i = 0; i < 8; i++)
	{
		if (i < 3)
			tstate[i + 8] ^= tstate[5 + i];
		else
			tstate[i + 8] ^= tstate[i - 3];
	}

	for (int i = 0; i < 8; i++)
	{

		tstate[i] ^= tstate[8 + i];
	}

}
void icaozuo(unsigned char* t1state)
{
	for (int i = 0; i < 16; i++)
	{
		tstate[i] = t1state[i];
	}

	for (int i = 0; i < 8; i++)
	{
		tstate[i] ^= tstate[i + 8];
	}

	for (int i = 0; i < 8; i++)
	{
		if (i < 3)
			tstate[i + 8] ^= tstate[5 + i];
		else
			tstate[i + 8] ^= tstate[i - 3];
	}

	for (int i = 0; i < 8; i++)
	{
		if (i < 6)
			tstate[i] ^= tstate[10 + i];
		else
			tstate[i] ^= tstate[2 + i];
	}
	for (int i = 0; i < 8; i++)
	{
		if (i < 6)
			tstate[i + 8] ^= tstate[2 + i];
		else
			tstate[i + 8] ^= tstate[i - 6];
	}

	for (int i = 0; i < 8; i++)
	{
		if (i < 7)
			tstate[i] ^= tstate[9 + i];
		else
			tstate[i] ^= tstate[1 + i];
	}

	for (int i = 0; i < 8; i++)
	{
		tstate[i + 8] ^= tstate[i];
	}

}


unsigned char state1[16];
unsigned char state2[16];

unsigned char statef[32];


unsigned char tstate1[16];
unsigned char tstate2[16];

unsigned char tstatef[32];

unsigned char tstate[16];

unsigned int diffs[16][16] = {
	16,0,0,0,   0,0,0,0,    0,0,0,0,    0,0,0,0,
	0,4,0,4,   0,4,0,4,    0,0,0,0,    0,0,0,0,
	0,0,4,0,   0,0,4,0,    4,0,0,0,    0,0,4,0,
	0,2,0,2,   0,2,0,2,    0,2,0,2,    0,2,0,2,

	0,0,0,4,   4,0,0,0,    0,0,0,0,    2,2,2,2,
	0,4,0,0,   4,0,0,0,    0,0,0,0,    2,2,2,2,
	0,2,2,0,   0,2,2,0,    0,0,2,2,    2,2,0,0,
	0,0,2,2,   0,0,2,2,    0,2,2,0,    2,0,0,2,

	0,0,0,0,   0,0,0,0,    4,2,4,2,    0,2,0,2,
	0,0,0,0,   0,0,0,0,    4,2,4,2,    0,2,0,2,
	0,0,4,0,   0,0,4,0,    0,2,0,2,    0,2,0,2,
	0,2,0,2,   0,2,0,2,    4,0,0,0,    0,0,4,0,

	0,0,0,0,   4,0,0,4,    0,2,0,2,    2,0,2,0,
	0,0,0,0,   4,4,0,0,    0,2,0,2,    2,0,2,0,
	0,2,2,0,   0,2,2,0,    0,2,2,0,    2,0,0,2,
	0,0,2,2,   0,0,2,2,    0,0,2,2,    2,2,0,0


};
unsigned long long num;

unsigned long long f1num;
unsigned long long f2num;
unsigned long long i1num;
unsigned long long i2num;


//权重 存在时 带权重进行计数
int ik;
void jiancha()
{

	int i = 0;
	while (i < 16)
	{
		if (tstate[i] == 0)
			i = 16;
		else if (i == 15)
			if (tstate[i] != 0)
				//printf("出现了");
				ik = 1;
		i++;
	}

}
//刻画，当前差分，可以到哪个位置；
char* firstone;

char* firsttwo;

char* inverseone;
char* inversetwo;


//新增6个
char* half161firstone;

char* half161firsttwo;



char* part32inverseone;
char* part32inversetwo;





unsigned int candiffs[16][16];

unsigned int icandiffs[16][16];


unsigned char tempc[32];

int panduanda32(unsigned char* a, unsigned char* b)
{
	//如果a大，返回1，否则0
	for (int i = 0; i < 32; i++)
	{
		if (tempc[i] > b[i])
			return 1;
		else if (tempc[i] < b[i])
		{

			for (int j = 0; j < 32; j++)
			{
				a[j] = a[j] ^ b[j];
				b[j] = a[j] ^ b[j];
				a[j] = a[j] ^ b[j];
			}
			return 0;
		}

		else if (i == 31)
		{

			if (tempc[i] == b[i])
				return 1;
		}

	}
	return 1;

}

int panduanda(unsigned char* a, unsigned char* b)
{

	//如果a大，返回1，否则0
	for (int i = 0; i < 16; i++)
	{
		if (tempc[i] > b[i])
			return 1;
		else if (tempc[i] < b[i])
		{

			for (int j = 0; j < 16; j++)
			{
				a[j] = a[j] ^ b[j];
				b[j] = a[j] ^ b[j];
				a[j] = a[j] ^ b[j];
			}
			return 0;
		}
	}
	return 1;


	//大的话要交换值。
}
int panduanxiao32(unsigned char* a, unsigned char* b)
{
	//如果a小，返回0，否则1
	for (int i = 0; i < 32; i++)
	{
		if (tempc[i] > b[i])
		{
			for (int j = 0; j < 32; j++)
			{
				a[j] = a[j] ^ b[j];
				b[j] = a[j] ^ b[j];
				a[j] = a[j] ^ b[j];
			}

			return 0;
		}
		else if (i == 31)
		{
			if (tempc[i] == b[i])
			{
				return 1;

			}
		}

		else if (tempc[i] < b[i])
		{
			return 1;
		}
	}
	return 1;

	//小的话要交换值。



}

int panduanxiao(unsigned char* a, unsigned char* b)
{

	//如果a小，返回0，否则1
	for (int i = 0; i < 16; i++)
	{
		if (tempc[i] > b[i])
		{
			for (int j = 0; j < 16; j++)
			{
				a[j] = a[j] ^ b[j];
				b[j] = a[j] ^ b[j];
				a[j] = a[j] ^ b[j];
			}

			return 0;
		}
		else if (tempc[i] < b[i])
		{
			return 1;
		}
	}
	return 1;

	//小的话要交换值。
}

void quicksort32(unsigned long long sti, unsigned long long tai, unsigned char* linshicharzu)
{


	unsigned long long tempi = sti;
	unsigned long long tempj = tai;
	for (int i = 0; i < 32; i++)
	{

		tempc[i] = linshicharzu[i + (sti << 5)];

	}
	int b;
	while (tempi != tempj)
	{
		b = 1;
		while ((b == 1) && (tempi < tempj))
		{
			b = panduanxiao32((linshicharzu + (tempi << 5)), (linshicharzu + (tempj << 5)));
			if (b == 1)
				tempj--;
		}

		b = 1;
		while ((b == 1) && (tempi < tempj))
		{
			b = panduanda32((linshicharzu + (tempj << 5)), (linshicharzu + (tempi << 5)));

			if (b == 1)
				tempi++;
		}
	}

	if (sti + 1 < tempi)
		quicksort32(sti, tempj - 1, linshicharzu);

	if (tai > tempj + 1)
		quicksort32(tempj + 1, tai, linshicharzu);

	return;


}



void maopaopaixu16(unsigned long long sti, unsigned long long tai, unsigned char* linshicharzu)
{
	unsigned long long tempi = sti;
	unsigned long long tempj = tai;

	for (tempi = sti; tempi < tai; tempi++)
	{//冒泡排序，i个元素和所有元素比，谁大就换
		for (tempj = tempi + 1; tempj < tai; tempj++)
		{
			for (int i = 0; i < 16; i++)
			{
				if (linshicharzu[(tempi << 4) + i] > linshicharzu[(tempj << 4) + i])
				{
					for (int j = 0; j < 16; j++)
					{


						linshicharzu[(tempi << 4) + j] = linshicharzu[(tempi << 4) + j] ^ linshicharzu[(tempj << 4) + j];
						linshicharzu[(tempj << 4) + j] = linshicharzu[(tempi << 4) + j] ^ linshicharzu[(tempj << 4) + j];
						linshicharzu[(tempi << 4) + j] = linshicharzu[(tempi << 4) + j] ^ linshicharzu[(tempj << 4) + j];
					}
					i = 16;

				}

			}





		}
	}





}


void quicksort(unsigned long long sti, unsigned long long tai, unsigned char* linshicharzu)
{
	unsigned long long tempi = sti;
	unsigned long long tempj = tai;
	for (int i = 0; i < 16; i++)
	{

		tempc[i] = linshicharzu[i + (sti << 4)];

	}
	int b;
	while (tempi != tempj)
	{
		b = 1;
		while ((b == 1) && (tempi < tempj))
		{
			b = panduanxiao((linshicharzu + (tempi << 4)), (linshicharzu + (tempj << 4)));
			if (b == 1)
				tempj--;
		}

		b = 1;
		while ((b == 1) && (tempi < tempj))
		{
			b = panduanda((linshicharzu + (tempj << 4)), (linshicharzu + (tempi << 4)));

			if (b == 1)
				tempi++;
		}
	}

	if (sti + 1 < tempi)
		quicksort(sti, tempj - 1, linshicharzu);

	if (tai > tempj + 1)
		quicksort(tempj + 1, tai, linshicharzu);

	return;
}


unsigned long long firsttwonum;
unsigned long long tempduibi;

int panduanxiangdeng(unsigned char* uct)
{
	//如果当前数大，返回1，如果数组数大，返回0，如果相等，exit();
	for (int i = 0; i < 16; i++)
	{
		if (uct[i] > half161firstone[(tempduibi << 4) + i])
			return 1;
		else if (uct[i] < half161firstone[(tempduibi << 4) + i])
		{
			return 0;
		}
		else if (i == 15)
		{
			if (uct[15] == half161firstone[(tempduibi << 4) + 15])
			{

				//printf("发生了碰撞，结束pamduanxiangdeng！！！！！！！！！！");

				//找到一队之后继续往后走
				exit(0);
			}
		}

	}



}
unsigned long long youbiao = 0;



unsigned char finalmatch[32];

int manzubudayu()
{
	for (int i = 0; i < 16; i++)
	{
		if (finalmatch[i] > half161firstone[(youbiao << 4) + i])
			return 0;

		if (finalmatch[i] < half161firstone[(youbiao << 4) + i])
			return 1;

		if (i == 15)
		{
			if (finalmatch[15] == half161firstone[(youbiao << 4) + 15])

			{
				printf("\n在比较的最后阶段，出现了碰撞budayu\n");
				printf("\n%llu\n", youbiao);
				for (int j = 0; j < 16; j++)
				{
					printf("%d", finalmatch[j]);
				}
				for (int j = 0; j < 16; j++)
				{
					printf("%d", half161firstone[(youbiao << 4) + j]);
				}


				exit(0);

			}
		}


	}


}


int manzubuxiaoyu()
{

	for (int i = 0; i < 16; i++)
	{
		if (finalmatch[i] < half161firstone[((youbiao - 1) << 4) + i])
			return 0;

		if (finalmatch[i] > half161firstone[((youbiao - 1) << 4) + i])
			return 1;

		if (i == 15)
		{
			if (finalmatch[15] == half161firstone[((youbiao - 1) << 4) + 15])

			{
				printf("\n在比较的最后阶段，出现了碰撞buxiaoyu\n");
				printf("\n%llu\n", youbiao);
				for (int j = 0; j < 16; j++)
				{
					printf("%d", finalmatch[j]);
				}
				printf("\n");

				for (int j = 0; j < 16; j++)
				{
					printf("%d", half161firstone[((youbiao - 1) << 4) + j]);
				}

				exit(0);

			}
		}


	}







}

int panduanshiji()
{
	//时机到了，就返回1；

	if (manzubudayu() && manzubuxiaoyu())
	{
		return 1;
	}
	else
	{
		return 0;
	}


}

int dayumax()
{

	for (int i = 0; i < 16; i++)
	{
		if (finalmatch[i] < half161firstone[((f1num - 1) << 4) + i])
			return 0;

		if (finalmatch[i] > half161firstone[((f1num - 1) << 4) + i])
			return 1;

		if (i == 15)
		{
			if (finalmatch[15] == half161firstone[((f1num - 1) << 4) + 15])

			{
				printf("\n在比较的最后阶段，出现了碰撞datyumax\n");


				printf("\n%llu\n", youbiao);
				for (int j = 0; j < 16; j++)
				{
					printf("%d", finalmatch[j]);
				}
				for (int j = 0; j < 16; j++)
				{
					printf("%d", half161firstone[(youbiao << 4) + j]);
				}
				exit(0);

			}
		}


	}




}

unsigned long long oldda, oldxiao;

void duibi()
{

	oldda = firsttwonum;
	oldxiao = 0;

	tempduibi = 0;
	//tstate1和2是β，进行一个逆的s盒之后，要进行搜索


	unsigned char tempmatch[32];

	for (int i = 0; i < 16; i++)
	{
		tempmatch[i] = tstate1[i];
		tempmatch[i + 16] = tstate2[i];

	}

	for (int i = 0; i < 32; i++)
	{
		finalmatch[i] = icandiffs[tempmatch[i]][0];//全部赋初值最小的s变换可以达到。
	}
	//int biao = 0;
	tempduibi = 0;



	for (; tempduibi < firsttwonum;)
	{
		//找匹配项，从前向后，走完停止，或者ti完了停止，

		//在这里进行debug




		//biao = panduanxiangdeng(finalmatch);
		//如果当前数大，返回1，如果数组数大，返回0，
		//只要数组数大，就跳出来
		youbiao = ((firsttwonum + tempduibi) >> 1);

		//这一步，使得当前数介于  当前角标的下面挨着
		while (panduanxiangdeng(finalmatch))
		{
			//说明当前数是大的，要找到比当前数大的最小的数。

			//printf("%llu\n", tempduibi);


			if (manzubudayu())//该if表示，当当前数比游标数小时候执行的程序
			{
				oldda = youbiao;
				// 

				youbiao = ((oldxiao + youbiao + 1) >> 1);


			}
			else
			{
				oldxiao = youbiao;
				youbiao = ((oldda + youbiao + 1) >> 1);



			}

			//如果游标接近最后了，结束判断

			if ((youbiao == (firsttwonum - 2)) || (youbiao == (firsttwonum - 1)))
			{
				//最后判断一次，然后结束。
				tempduibi = youbiao;
				panduanxiangdeng(finalmatch);
				tempduibi = firsttwonum - 1;
				panduanxiangdeng(finalmatch);

				return;
			}

			//如果满足某种条件，就把游标的值赋给ti：要求，上一个不大于当前值，下一个不小于当前值。
			if (panduanshiji())
			{
				tempduibi = youbiao;
				oldda = firsttwonum;
				oldxiao = tempduibi;

				//	printf("当前的对比位置%llu\n", tempduibi);
			}




		}

		//此时需要修改当前值，使得当前数，大于当前角标


		while (!panduanxiangdeng(finalmatch))
		{
			/*if (num == 5 && youbiao > 27500000)
			{
				for (int ii = 0; ii < 32; ii++)
				{
					printf("%x", firsttwo[(tempduibi << 5) + ii]);
				}
				printf("\n");


				for (int ii = 0; ii < 32; ii++)
				{
					printf("%x", tempmatch[ii]);
				}
				printf("\n");

				for (int ii = 0; ii < 32; ii++)
				{
					printf("%x", finalmatch[ii]);
				}
				printf("\n");
				printf("\n");


			}*/
			//从前往后对比，如果大数相等，就往后比找到第一个不相等的，加，如果满了，就找前面加一个。

			for (int i = 0; i < 32; i++)
			{
				if (finalmatch[i] < firsttwo[(tempduibi << 5) + i])
				{
					if (icandiffs[tempmatch[i]][finalmatch[i]] != 0)
					{
						finalmatch[i] = icandiffs[tempmatch[i]][finalmatch[i]];
						//一旦加了，后面的全部改为最小值。
						for (int j = i + 1; j < 32; j++)
						{
							finalmatch[j] = icandiffs[tempmatch[j]][0];
						}
						i = 32;
					}
					else if (i > 0)
					{
						//前面的都相等，这个又加不了，往前找一个能加的加上
						//0到i-1 需要有一个解

						for (int j = i - 1; j > -1; j--)
						{
							if (icandiffs[tempmatch[j]][finalmatch[j]] != 0)
							{
								finalmatch[j] = icandiffs[tempmatch[j]][finalmatch[j]];
								//一旦加了，后面的全部改为最小值。
								for (int k = j + 1; k < 32; k++)
								{
									finalmatch[k] = icandiffs[tempmatch[k]][0];
								}

								//if (num == 5&&youbiao>27500000)
								//{

								//	//printf("123\n");
								//	//打印当前比较的数，打印原始，打印现在是啥
								//	for (int ii = 0; ii < 32; ii++)
								//	{
								//		printf("%x",firsttwo[(tempduibi<<5)+ii]);
								//	}
								//	printf("\n");


								//	for (int ii = 0; ii < 32; ii++)
								//	{
								//		printf("%x", tempmatch[ii]);
								//	}
								//	printf("\n");

								//	for (int ii = 0; ii < 32; ii++)
								//	{
								//		printf("%x", finalmatch[ii]);
								//	}
								//	printf("\n");
								//	printf("\n");

								//}

								i = 32;
								j = -2;

							}


							else if (j == 0)
							{
								return 0;
							}


						}





					}

					else
					{
						return 0;

					}





				}






			}

			if (dayumax())
				return 0;

		}




	}





}

unsigned long long qian1lingjie[16];
unsigned long long qian2lingjie[16];

unsigned long long hou1lingjie[16];
unsigned long long hou2lingjie[16];

int diffalpha = 1;
int diffbeita = 4;

//11和α1匹配成功，寻找12和α2的匹配成功，比较22和α2的匹配，比较21和α1的匹配，1*和2*一旦出错
//2*对不上，就换一个， 1*不换，1*对不上，往下走，11把α1比较结束，则结束。
	//比较四部


void step1(unsigned long long b1num, int qianqujian, int houqujian)
{
	//b1num表示的是，当前搜索到第几个β了
	//half161firstone = (char*)malloc(5000000);
	//half162firstone = (char*)malloc(5000000);
	//half161firsttwo = (char*)malloc(5000000);
	//half162firsttwo = (char*)malloc(5000000);
	//part32inverseone = (char*)malloc(10000000);
	//part32inversetwo = (char*)malloc(10000000);
	// 
	// 
	//β和阿尔法的对比，全部是由s盒方法进行
	oldda = qian1lingjie[houqujian];
	oldxiao = qian1lingjie[qianqujian];

	printf("当前区间号：%d", houqujian);
	f1num = qian1lingjie[houqujian];
	unsigned char tempmatch[32];
	for (int i = 0; i < 32; i++)
	{
		tempmatch[i] = part32inverseone[(b1num << 5) + i];
	}

	for (int i = 0; i < 32; i++)
	{
		finalmatch[i] = icandiffs[tempmatch[i]][0];//全部赋初值最小的s变换可以达到。
	}
	//int biao = 0;
	tempduibi = 0;

	for (; tempduibi < f1num;)
	{
		//找匹配项，从前向后，走完停止，或者ti完了停止，

		//在这里进行debug




		//biao = panduanxiangdeng(finalmatch);
		//如果当前数大，返回1，如果数组数大，返回0，
		//只要数组数大，就跳出来
		youbiao = ((f1num + tempduibi) >> 1);

		//这一步，使得当前数介于  当前角标的下面挨着
		while (panduanxiangdeng(finalmatch))
		{
			//说明当前数是大的，要找到比当前数大的最小的数。

			//printf("%llu\n", tempduibi);


			if (manzubudayu())//该if表示，当当前数比游标数小时候执行的程序
			{
				oldda = youbiao;
				// 

				youbiao = ((oldxiao + youbiao + 1) >> 1);


			}
			else
			{
				oldxiao = youbiao;
				youbiao = ((oldda + youbiao + 1) >> 1);


			}

			//如果游标接近最后了，结束判断

			if ((youbiao == (f1num - 2)) || (youbiao == (f1num - 1)))
			{
				//最后判断一次，然后结束。
				tempduibi = youbiao;
				panduanxiangdeng(finalmatch);
				tempduibi = f1num - 1;
				panduanxiangdeng(finalmatch);
				///  到最后了，不行
				if (candiffs[diffalpha][houqujian] != 0)
					step1(b1num, houqujian, candiffs[diffalpha][houqujian]);
				return;
			}

			//如果满足某种条件，就把游标的值赋给ti：要求，上一个不大于当前值，下一个不小于当前值。
			if (panduanshiji())
			{
				tempduibi = youbiao;
				oldda = f1num;
				oldxiao = tempduibi;

				//	printf("当前的对比位置%llu\n", tempduibi);
			}




		}

		//此时需要修改当前值，使得当前数，大于当前角标


		while (!panduanxiangdeng(finalmatch))
		{
			/*if (num == 5 && youbiao > 27500000)
			{
				for (int ii = 0; ii < 32; ii++)
				{
					printf("%x", firsttwo[(tempduibi << 5) + ii]);
				}
				printf("\n");


				for (int ii = 0; ii < 32; ii++)
				{
					printf("%x", tempmatch[ii]);
				}
				printf("\n");

				for (int ii = 0; ii < 32; ii++)
				{
					printf("%x", finalmatch[ii]);
				}
				printf("\n");
				printf("\n");


			}*/
			//从前往后对比，如果大数相等，就往后比找到第一个不相等的，加，如果满了，就找前面加一个。

			for (int i = 0; i < 16; i++)
			{
				if (finalmatch[i] < half161firstone[(tempduibi << 4) + i])
				{
					if (icandiffs[tempmatch[i]][finalmatch[i]] != 0)
					{
						finalmatch[i] = icandiffs[tempmatch[i]][finalmatch[i]];
						//一旦加了，后面的全部改为最小值。
						for (int j = i + 1; j < 16; j++)
						{
							finalmatch[j] = icandiffs[tempmatch[j]][0];
						}
						i = 32;
					}
					else if (i > 0)
					{
						//前面的都相等，这个又加不了，往前找一个能加的加上
						//0到i-1 需要有一个解

						for (int j = i - 1; j > -1; j--)
						{
							if (icandiffs[tempmatch[j]][finalmatch[j]] != 0)
							{
								finalmatch[j] = icandiffs[tempmatch[j]][finalmatch[j]];
								//一旦加了，后面的全部改为最小值。
								for (int k = j + 1; k < 16; k++)
								{
									finalmatch[k] = icandiffs[tempmatch[k]][0];
								}


								i = 32;
								j = -2;

							}


							else if (j == 0)
							{//不能再变大了，不行

								if (candiffs[diffalpha][houqujian] != 0)
									step1(b1num, houqujian, candiffs[diffalpha][houqujian]);
								return 0;


							}


						}





					}

					else
					{//不能再大了，不行


						if (candiffs[diffalpha][houqujian] != 0)
							step1(b1num, houqujian, candiffs[diffalpha][houqujian]);
						return 0;

					}





				}






			}

			if (dayumax())
			{
				//比上界大 不行

				if (candiffs[diffalpha][houqujian] != 0)
					step1(b1num, houqujian, candiffs[diffalpha][houqujian]);
				return 0;
			}

		}




	}







}


unsigned char resortpos[32] = { 16, 17, 0, 1, 18, 19, 2, 3, 14, 15, 24, 25, 8, 9, 30, 31, 4, 5, 22, 23, 6, 7, 20, 21, 28, 29, 12, 13, 26, 27, 10, 11 };




int WHETHERBBOTH(unsigned char* uncomparechar)
{

	for (size_t i = 0; i < 8; i++)
	{
		if (uncomparechar[i] > half161firstone[(youbiao << 4) + i])
			return 0;
		else if (uncomparechar[i] < half161firstone[(youbiao << 4) + i])
		{
			i = 8;
		}
	}

	for (size_t i = 0; i < 8; i++)
	{
		if (uncomparechar[i] > half161firstone[((youbiao - 1) << 4) + i])
			return 1;
		else if (uncomparechar[i] < half161firstone[((youbiao - 1) << 4) + i])
		{
			return 0;
		}

	}

	return 1;

}
int MAXpare_step2()
{

	for (int i = 0; i < 8; i++)
	{
		if (step2_match[i] < part32inversetwo[((Step2_Big_Num - 1) << 4) + i])
			return 0;

		if (step2_match[i] > part32inversetwo[((Step2_Big_Num - 1) << 4) + i])
			return 1;

		if (i == 7)
		{
			if (step2_match[7] == part32inversetwo[((Step2_Big_Num - 1) << 4) + 7])
			{



				return 2;

			}
		}


	}

}

int MAXpare()
{

	for (int i = 0; i < 8; i++)
	{
		if (finalmatch[i] < half161firstone[((Now_Big_Num - 1) << 4) + i])
			return 0;

		if (finalmatch[i] > half161firstone[((Now_Big_Num - 1) << 4) + i])
			return 1;

		if (i == 7)
		{
			if (finalmatch[7] == half161firstone[((Now_Big_Num - 1) << 4) + 7])
			{



				return 2;

			}
		}


	}

}



int YouBiaocompare(unsigned char* uncomparechar)
{
	//如果游标值大，返回1，游标值小，返回0
	for (size_t i = 0; i < 8; i++)
	{
		if (uncomparechar[i] > half161firstone[(youbiao << 4) + i])
			return 0;
		else if (uncomparechar[i] < half161firstone[(youbiao << 4) + i])
		{
			return 1;
		}

	}

	return 0;


}





int CompareSIZE8(unsigned char* uncomparechar)
{//如果uncomparechar大，返回1 小于 返回0，相等，进入第二步

	for (size_t i = 0; i < 8; i++)
	{
		if (uncomparechar[i] > half161firstone[(tempduibi << 4) + i])
			return 1;
		else if (uncomparechar[i] < half161firstone[(tempduibi << 4) + i])
		{
			return 0;
		}
		else if (i == 7)
		{
			//当前的α已经匹配成功

			Select_First_Step_two();
			tempduibi++;
			oldda = Now_Big_Num;
			oldxiao = tempduibi;
			return 0;
		}
	}
}


void Select_First_Step(unsigned long long Index_Beta, int Begin_Index, int Tail_Index)
{
	//这是阿尔法的区间。
	First_NUM = Begin_Index;
	oldda = qian1lingjie[Tail_Index];
	oldxiao = qian1lingjie[Begin_Index];
	Now_Big_Num = qian1lingjie[Tail_Index];

	//printf("%llu ", oldxiao);
	//printf("%llu\n", Now_Big_Num);
	unsigned char tempmatch[16];

	for (int i = 0; i < 16; i++)
	{
		tempmatch[i] = part32inverseone[(Index_Beta << 4) + i];
	}
	for (int i = 0; i < 8; i++)
	{
		finalmatch[i] = icandiffs[tempmatch[i]][0];//全部赋初值最小的s变换可以达到。
	}
	//为后续做准备，保留
	for (int i = 8; i < 16; i++)
	{
		finalmatch[i] = part32inverseone[(Index_Beta << 4) + i];//保留将来可能的变换
	}


	//int biao = 0;
	tempduibi = oldxiao;//表示当前的实际进展

	for (; tempduibi < Now_Big_Num;)
	{
		youbiao = ((Now_Big_Num + tempduibi + 1) >> 1);

		//finalmatch如果大于当前脚标的数，就找到比他大的第一个数，如果小的话，就差分变换

		while (CompareSIZE8(finalmatch))//当前数大，要提高tempduibi的值
		{
			if (YouBiaocompare(finalmatch))
			{

				oldda = youbiao;
				youbiao = ((oldxiao + youbiao) >> 1);


			}
			else
			{
				oldxiao = youbiao;
				youbiao = ((oldda + youbiao + 1) >> 1);
			}


			if ((youbiao == (Now_Big_Num - 2)) || (youbiao == (Now_Big_Num - 1)))
			{

				tempduibi = youbiao;
				CompareSIZE8(finalmatch);
				tempduibi = Now_Big_Num - 1;
				CompareSIZE8(finalmatch);
				//之后，要尽行第二位置的对比结果
				if (candiffs[diffalpha][Tail_Index] != 0)
					Select_First_Step(Index_Beta, Tail_Index, candiffs[diffalpha][Tail_Index]);
				return 0;
			}

			if (WHETHERBBOTH(finalmatch))//找到了临界值
			{
				tempduibi = youbiao;
				oldda = Now_Big_Num;
				oldxiao = tempduibi;
			}






		}




		while (!CompareSIZE8(finalmatch))//当前数小，要修改s盒进行匹配
		{

			for (int i = 0; i < 8; i++)
			{
				if (finalmatch[i] < half161firstone[(tempduibi << 4) + i])
				{
					if (icandiffs[tempmatch[i]][finalmatch[i]] != 0)
					{
						finalmatch[i] = icandiffs[tempmatch[i]][finalmatch[i]];

						for (int j = i + 1; j < 8; j++)
						{
							finalmatch[j] = icandiffs[tempmatch[j]][0];
						}
						i = 8;
					}
					else if (i > 0)
					{
						for (int j = i - 1; j > -1; j--)
						{
							if (icandiffs[tempmatch[j]][finalmatch[j]] != 0)
							{
								finalmatch[j] = icandiffs[tempmatch[j]][finalmatch[j]];
								for (int k = j + 1; k < 8; k++)
								{
									finalmatch[k] = icandiffs[tempmatch[k]][0];
								}

								i = 8;
								j = -2;
							}

							else if (j == 0)
							{
								if (candiffs[diffalpha][Tail_Index] != 0)
									Select_First_Step(Index_Beta, Tail_Index, candiffs[diffalpha][Tail_Index]);
								return 0;
								//此处说明，当前最大差分都不如脚标大。下一个
								//return 0;
							}


						}
					}

					else
					{
						if (candiffs[diffalpha][Tail_Index] != 0)
							Select_First_Step(Index_Beta, Tail_Index, candiffs[diffalpha][Tail_Index]);
						return 0;

					}







				}


			}


			if (MAXpare() == 1)//已经比最大的大
			{
				if (candiffs[diffalpha][Tail_Index] != 0)
					Select_First_Step(Index_Beta, Tail_Index, candiffs[diffalpha][Tail_Index]);
				return 0;
			}
			else if (MAXpare() == 2)
			{
				//进入第二轮
				youbiao = Now_Big_Num - 1;
				tempduibi = youbiao;
				Select_First_Step_two();

				if (candiffs[diffalpha][Tail_Index] != 0)
					Select_First_Step(Index_Beta, Tail_Index, candiffs[diffalpha][Tail_Index]);
				return 0;
			}

		}




	}






	if (candiffs[diffalpha][Tail_Index] != 0)
		Select_First_Step(Index_Beta, Tail_Index, candiffs[diffalpha][Tail_Index]);
	return 0;

}

int CompareSIZE8_step2()
{//如果uncomparechar大，返回1 小于 返回0，相等，进入第二步

	for (size_t i = 0; i < 8; i++)
	{
		if (step2_match[i] > part32inversetwo[(Temp_duibi2 << 4) + i])
			return 1;
		else if (step2_match[i] < part32inversetwo[(Temp_duibi2 << 4) + i])
		{
			return 0;
		}
		else if (i == 7)
		{
			//当前的α已经匹配成功


			FINAL_step();

			Temp_duibi2++;
			oldda_step2 = Step2_Big_Num;
			oldxiao_step = Temp_duibi2;
			//Select_First_Step_two();
			return 0;
		}
	}
}



int WHETHERBBOTH_step2()
{

	for (size_t i = 0; i < 8; i++)
	{
		if (step2_match[i] > part32inversetwo[(step2_youbiao << 4) + i])
			return 0;
		else if (step2_match[i] < part32inversetwo[(step2_youbiao << 4) + i])
		{
			i = 8;
		}
	}

	for (size_t i = 0; i < 8; i++)
	{
		if (step2_match[i] > part32inversetwo[((step2_youbiao - 1) << 4) + i])
			return 1;
		else if (step2_match[i] < part32inversetwo[((step2_youbiao - 1) << 4) + i])
		{
			return 0;
		}

	}

	return 1;



}








void Select_First_Step_two_detail(int Begin_Index, int Tail_Index)//第二轮要根据半截阿尔法1，找合适的β2.
{
	Second_NUM = Begin_Index;

	oldda_step2 = hou2lingjie[Tail_Index];
	oldxiao_step = hou2lingjie[Begin_Index];
	Step2_Big_Num = hou2lingjie[Tail_Index];

	//printf("%llu ", oldxiao);
	//printf("%llu\n", Now_Big_Num);
	unsigned char tempmatch[16];


	//阿尔法固定，去找贝塔
	for (int i = 0; i < 8; i++)
	{
		tempmatch[i] = Alpha_pashalf8[i];
	}
	for (int i = 0; i < 8; i++)
	{
		step2_match[i] = candiffs[tempmatch[i]][0];//全部赋初值最小的s变换可以达到。
	}
	//为后续做准备，保留

	Temp_duibi2 = oldxiao_step;

	for (; Temp_duibi2 < Step2_Big_Num;)
	{
		step2_youbiao = ((Step2_Big_Num + Temp_duibi2 + 1) >> 1);


		//当前数大的话，提高Temp_duibi2的值
		while (CompareSIZE8_step2())
		{

			if (YouBiaocompare_step2())
			{
				oldda_step2 = step2_youbiao;
				step2_youbiao = ((oldxiao_step + step2_youbiao) >> 1);
			}
			else
			{
				oldxiao_step = step2_youbiao;
				step2_youbiao = ((oldda_step2 + step2_youbiao + 1) >> 1);
			}

			if ((step2_youbiao == (Step2_Big_Num - 2)) || (step2_youbiao == (Step2_Big_Num - 1)))
			{

				Temp_duibi2 = step2_youbiao;
				CompareSIZE8_step2();
				Temp_duibi2 = Step2_Big_Num - 1;
				CompareSIZE8_step2();

				return 0;
			}

			if (WHETHERBBOTH_step2())//找到了临界值
			{
				Temp_duibi2 = step2_youbiao;
				oldda_step2 = Step2_Big_Num;
				oldxiao_step = Temp_duibi2;
			}






		}

		while (!CompareSIZE8_step2())//当前数小，要修改s盒进行匹配
		{

			for (int i = 0; i < 8; i++)
			{
				if (step2_match[i] < part32inversetwo[(Temp_duibi2 << 4) + i])
				{
					if (candiffs[tempmatch[i]][step2_match[i]] != 0)
					{
						step2_match[i] = candiffs[tempmatch[i]][step2_match[i]];

						for (int j = i + 1; j < 8; j++)
						{
							step2_match[j] = candiffs[tempmatch[j]][0];
						}
						i = 8;
					}
					else if (i > 0)
					{
						for (int j = i - 1; j > -1; j--)
						{
							if (candiffs[tempmatch[j]][step2_match[j]] != 0)
							{
								step2_match[j] = candiffs[tempmatch[j]][step2_match[j]];
								for (int k = j + 1; k < 8; k++)
								{
									step2_match[k] = candiffs[tempmatch[k]][0];
								}

								i = 8;
								j = -2;
							}

							else if (j == 0)
							{

								return 0;
								//此处说明，当前最大差分都不如脚标大。下一个
								//return 0;
							}


						}
					}

					else
					{

						return 0;

					}





				}
			}



			if (MAXpare_step2() == 1)//已经比最大的大
			{

				return 0;
			}
			else if (MAXpare_step2() == 2)
			{
				//进入第二轮
				step2_youbiao = Step2_Big_Num - 1;
				Temp_duibi2 = step2_youbiao;
				//Select_First_Step_two();
				//最后一轮
				FINAL_step();

				return 0;
			}




		}





	}

	return 0;
}
//看看第一关多少通过
unsigned long long currentbeta;
unsigned t1441d85d;
void Select_First_Step_two()//第二轮要根据半截阿尔法1，找合适的β2.
{
	can_go_alpha++;
	//printf("找到一对");
	//打印证据

	/*if (part32inverseone[(currentbeta << 4) + 7] == 0xd)
		t1441d85d++;
	else
	{
		printf("\n%d\n", t1441d85d);


		for (size_t i = 0; i < 1000; i++)
		{
			for (size_t j = 0; j < 8; j++)
			{

				printf("%x", part32inverseone[(i << 4) + j]);
			}
			printf("\n");
		}
		exit(0);
	}*/




	/*for (size_t i = 0; i < 8; i++)
	{

		printf("%x",part32inverseone[(currentbeta<<4)+i]);

	}
	printf("\n");


	for (size_t i = 0; i < 8; i++)
	{

		printf("%x", finalmatch[i]);

	}
	printf("\n");

	for (size_t i = 0; i < 8; i++)
	{

		printf("%x", half161firstone[(tempduibi << 4) + i]);

	}
	printf("\n");
	printf("\n");*/

	for (size_t i = 0; i < 8; i++)
	{

		//最后作为参考
		Alpha_firhalf8[i] = half161firstone[(tempduibi << 4) + i];

		//pas和贝塔的前8个对比寻找合适的
		Alpha_pashalf8[i] = half161firstone[(tempduibi << 4) + i + 8];

	}



	/*for (size_t i = 0; i < 16; i++)
	{
		printf("%x",finalmatch[i]);

	}
	printf("\n");
	for (size_t i = 0; i < 16; i++)
	{
		printf("%x", half161firstone[(tempduibi<<4)+i]);

	}
	printf("\n");*/

	unsigned oldindex = 0;
	//进入这里，首先要对贝塔二的区间进行分类

	//贝塔二的区间已经确定

	//贝塔2的区间是由一开始决定的
	int key_2=0;
	for (size_t i = 1; i < 16; i++)
	{
		if (currentbeta < hou1lingjie[i])//一区间
		{
			Select_First_Step_two_detail(key_2, i);
			i = 16;
			return 0 ;
		}
		if (hou1lingjie[i] != 0)
			key_2 = i;

	}






}


int YouBiaocompare_step2()
{
	for (size_t i = 0; i < 8; i++)
	{
		if (step2_match[i] > part32inversetwo[(step2_youbiao << 4) + i])
			return 0;
		else if (step2_match[i] < part32inversetwo[(step2_youbiao << 4) + i])
		{
			return 1;
		}

	}

	return 0;


}
unsigned long long final_da, final_xiao, final_big;

unsigned char alpha2_match[16];
unsigned long long alpha2_youbiao, alpha2_duibi;

int MAXpare_final()
{

	for (int i = 0; i < 16; i++)
	{
		if (alpha2_match[i] < half161firsttwo[((final_big - 1) << 4) + i])
			return 0;

		if (alpha2_match[i] > half161firsttwo[((final_big - 1) << 4) + i])
			return 1;

		if (i == 15)
		{
			if (alpha2_match[15] == half161firsttwo[((final_big - 1) << 4) + 15])
			{



				return 2;

			}
		}


	}

}
unsigned imposs_num = 0;
int Compare_final16()
{

	for (size_t i = 0; i < 16; i++)
	{
		if (alpha2_match[i] > half161firsttwo[(alpha2_duibi << 4) + i])
			return 1;
		else if (alpha2_match[i] < half161firsttwo[(alpha2_duibi << 4) + i])
		{
			return 0;
		}
		else if (i == 15)
		{


			//imposs_num++;

			NOW_ISTIME_CLOSE = 1;



			alpha2_duibi++;

			//printf("\n\n");

			return 0;



		}
	}

	printf("不可能到这里");
}
int YouBiaocompare16_final()
{
	//如果游标值大，返回1，游标值小，返回0
	for (size_t i = 0; i < 16; i++)
	{
		if (alpha2_match[i] > half161firsttwo[(alpha2_youbiao << 4) + i])
			return 0;
		else if (alpha2_match[i] < half161firsttwo[(alpha2_youbiao << 4) + i])
		{
			return 1;
		}

	}

	return 0;


}
int WHETHERBBOTH_final()
{

	for (size_t i = 0; i < 16; i++)
	{
		if (alpha2_match[i] > half161firsttwo[(alpha2_youbiao << 4) + i])
			return 0;
		else if (alpha2_match[i] < half161firsttwo[(alpha2_youbiao << 4) + i])
		{
			i = 16;
		}
	}

	for (size_t i = 0; i < 16; i++)
	{
		if (alpha2_match[i] > half161firsttwo[((alpha2_youbiao - 1) << 4) + i])
			return 1;
		else if (alpha2_match[i] < half161firsttwo[((alpha2_youbiao - 1) << 4) + i])
		{
			return 0;
		}

	}

	return 1;

}




void Select_First_Step_final_detail(int Begin_Index, int Tail_Index)
{//区间已经确定，就在这里找;

	final_da = qian2lingjie[Tail_Index];
	final_xiao = qian2lingjie[Begin_Index];
	final_big = qian2lingjie[Tail_Index];
	//根据合体β，找阿尔法;
	unsigned char tempmatch[16];

	for (int i = 0; i < 8; i++)
	{
		tempmatch[i] = part32inverseone[(currentbeta << 4) + i + 8];
	}
	for (int i = 0; i < 8; i++)
	{
		tempmatch[i + 8] = part32inversetwo[(Temp_duibi2 << 4) + i + 8];
	}

	for (int i = 0; i < 16; i++)
	{
		alpha2_match[i] = icandiffs[tempmatch[i]][0];//全部赋初值最小的s变换可以达到。
	}

	alpha2_duibi = final_xiao;

	for (; alpha2_duibi < final_big;)
	{
		alpha2_youbiao = ((final_big + alpha2_duibi + 1) >> 1);


		while (Compare_final16())
		{

			if (YouBiaocompare16_final())
			{

				final_da = alpha2_youbiao;
				alpha2_youbiao = ((final_xiao + alpha2_youbiao) >> 1);

			}

			else
			{
				final_xiao = alpha2_youbiao;
				alpha2_youbiao = ((final_da + alpha2_youbiao + 1) >> 1);

			}
			if ((alpha2_youbiao == (final_big - 2)) || (alpha2_youbiao == (final_big - 1)))
			{

				alpha2_duibi = alpha2_youbiao;
				Compare_final16();
				alpha2_duibi = final_big - 1;
				Compare_final16();
				//之后，要尽行第二位置的对比结果			
				return 0;
			}

			if (WHETHERBBOTH_final)//找到了临界值
			{
				alpha2_duibi = alpha2_youbiao;
				final_da = final_big;
				final_xiao = alpha2_duibi;
			}





		}
		while (!Compare_final16())//当前数小，要修改s盒进行匹配
		{
			for (int i = 0; i < 16; i++)
			{
				if (alpha2_match[i] < half161firsttwo[(alpha2_duibi << 4) + i])
				{
					if (icandiffs[tempmatch[i]][alpha2_match[i]] != 0)
					{
						alpha2_match[i] = icandiffs[tempmatch[i]][alpha2_match[i]];

						for (int j = i + 1; j < 16; j++)
						{
							alpha2_match[j] = icandiffs[tempmatch[j]][0];
						}
						i = 16;
					}
					else if (i > 0)
					{
						for (int j = i - 1; j > -1; j--)
						{
							if (icandiffs[tempmatch[j]][alpha2_match[j]] != 0)
							{
								alpha2_match[j] = icandiffs[tempmatch[j]][alpha2_match[j]];
								for (int k = j + 1; k < 16; k++)
								{
									alpha2_match[k] = icandiffs[tempmatch[k]][0];
								}

								i = 16;
								j = -2;
							}

							else if (j == 0)
							{

								return 0;
								//此处说明，当前最大差分都不如脚标大。下一个
								//return 0;
							}


						}
					}

					else
					{

						return 0;

					}







				}


			}

			if (MAXpare_final() == 1)//已经比最大的大
			{

				return 0;
			}
			else if (MAXpare_final() == 2)
			{
				//进入第二轮
				//printf("找到碰撞");
				NOW_ISTIME_CLOSE = 1;
				return 0;
			}





		}


	}

	return 0;

}


void FINAL_step()
{
	can_go_beta2++;
	//进行最后一轮，两个贝塔的后半段合成一个新的16，和阿尔法2进行对比
	// 先验证

	/*for (size_t i = 0; i < 8; i++)
	{

		printf("%x",part32inverseone[(currentbeta<<4)+i]);

	}
	printf(" ");
	for (size_t i = 0; i < 8; i++)
	{

		printf("%x", part32inversetwo[(Temp_duibi2 << 4) + i]);

	}


	printf("\n");


	for (size_t i = 0; i < 8; i++)
	{

		printf("%x", finalmatch[i]);

	}
	printf(" ");
	for (size_t i = 0; i < 8; i++)
	{

		printf("%x", step2_match[i]);

	}


	printf("\n");

	for (size_t i = 0; i < 8; i++)
	{

		printf("%x", half161firstone[(tempduibi << 4) + i]);

	}
	printf(" ");
	for (size_t i = 0; i < 8; i++)
	{

		printf("%x", half161firstone[(tempduibi << 4) + i+8]);

	}

	printf("\n");
	printf("\n");*/


	//经过验证没问题，两个β可以和α1进行全配对，最后一步，两个贝塔的后半部分合体，去α2集合中找全配对。

	//找的是阿尔法
	Select_First_Step_final_detail(First_NUM, candiffs[diffalpha][First_NUM]);

}




#pragma endregion


//写一个函数，第一步β1前8个去找阿尔法1的前八个的算法，要求参数，传入β1的是第几个，搜索

//tempduibi zhidao finalmatch（贝塔一）知道 需要知道现在在第几轮；

unsigned char P[32] = { 2,3,6,7,8,9,12,13,0,1,4,5,14,15,10,11,20,21,30,31,26,27,16,17,18,19,28,29,24,25,22,23 };

unsigned char iP[32] = { 8,9,0,1,10,11,2,3,4,5,14,15,6,7,12,13   ,6,7,8,9,0,1,14,15,12,13,4,5,10,11,2,3 };
int temp;








int chafen = 0;
//int chafensx = 1;
int chafenpos = 0;
clock_t start;
clock_t end;




void pos_select(int input_pos, int out_pos,int input_diff,int output_diff)
{
	NOW_ISTIME_CLOSE = 0;
	f1num = 0;
	f2num = 0;
	i1num = 0;
	i2num = 0;

	diffalpha = input_diff;
	diffbeita = output_diff;

	for (int i = 0; i < 16; i++)
	{
		qian1lingjie[i] = 0;
		qian2lingjie[i] = 0;
		hou1lingjie[i] = 0;
		hou2lingjie[i] = 0;

	}


	//start = clock();




	unsigned t1, t2, t3, t4;

	int i, j, k, l, p, n;



	for (i = 0; i < 16; i++)
	{
		tstate1[i] = 0;
	}



	caozuo(tstate1);
	for (i = 0; i < 16; i++)
	{
		tstate1[i] = 0;
	}
	for (i = 0; i < 16; i++)
	{
		isbox[sbox[i]] = i;
	}

	for (i = 0; i < 16; i++)
	{
		for (j = 0; j < 16; j++)
		{
			isboxdiff[i][j] = 0;

		}
	}
	isboxdiff[0][0] = 0;

	for (i = 0; i < 16; i++)
	{
		for (j = 0; j < 16; j++)
		{
			t1 = i;
			t2 = t1 ^ j;//这是输入的差分
			isboxdiff[j][isbox[t1] ^ isbox[t2]]++;
		}
	}

	for (int i = 0; i < 16; i++)
	{
		for (int j = 0; j < 16; j++)
		{
			candiffs[i][j] = 0;
			icandiffs[i][j] = 0;
		}
	}

	int f0 = 0;


	for (int i = 1; i < 16; i++)//对每个初始差分进行操作
	{
		int f0 = 0;
		for (int j = 1; j < 16; j++)
		{
			if (diffs[i][j] != 0)
			{
				candiffs[i][f0] = j;
				f0 = j;
			}
		}
	}

	for (int i = 1; i < 16; i++)//对每个初始差分进行操作
	{
		int f0 = 0;
		for (int j = 1; j < 16; j++)
		{
			if (isboxdiff[i][j] != 0)
			{
				icandiffs[i][f0] = j;
				f0 = j;
			}
		}
	}








	for (int i = 0; i < 16; i++)
	{
		state1[i] = 0;
		state2[i] = 0;
	}




	//选取输入差分的位置，第几位置很重要

	//存第一列的全扩散差分
	for (int i = input_pos; i < input_pos + 1; i++)//选取含差分的位置
	{
		for (int im = 0; im < 16; im++)
		{
			state1[im] = 0;
			state2[im] = 0;
		}
		for (int im = 0; im < 32; im++)
		{
			statef[im] = 0;

		}
		//该差分变为
		//该位置的差分是j///////////////////////////////////////////////////////////////

		//限制输入差分为1
		for (int j = input_diff; j < input_diff+1; j++)//该输入差分先遍历，，i，j就是最后的结果角标
		{

			num = 0;//一共有12个活跃s盒，第一轮一个，第二轮11个活跃s盒 一个活跃s盒16种可能，就是2^48的数量级，最后的结果要除以这个数
			for (int im = 0; im < 16; im++)
			{
				state1[im] = 0;
				state2[im] = 0;
			}
			for (int im = 0; im < 32; im++)
			{
				statef[im] = 0;

			}



			statef[i] = j;
			if (i < 16)
				state1[i] = j;
			else
			{
				state2[i - 16] = j;
			}
			//sw操作
			int tempsw = 0;
			for (int ti = 0; ti < 8; ti++)
			{
				tempsw = state1[ti + 8];
				state1[ti + 8] = state2[ti];
				state2[ti] = tempsw;


				tempsw = statef[ti + 8];
				statef[ti + 8] = statef[ti + 16];
				statef[ti + 16] = tempsw;
			}


			caozuo(state1);


			//最一开始的初值，f表示初值确定之后的操作
			for (int ti = 0; ti < 16; ti++)
			{
				tstate1[ti] = tstate[ti];
				tstatef[ti] = tstate[ti];

			}

			caozuo(state2);

			for (int ti = 0; ti < 16; ti++)
			{

				tstate2[ti] = tstate[ti];
				tstatef[ti + 16] = tstate[ti];
			}







			ik = 0;
			//交换
			for (int ti = 0; ti < 8; ti++)
			{
				temp = tstatef[ti + 16];
				tstatef[ti + 16] = tstatef[ti + 8];
				tstatef[ti + 8] = temp;
			}



			for (int ti = 0; ti < 16; ti++)
			{
				tstate[ti] = tstatef[ti];
			}
			for (int ti = 0; ti < 16; ti++)
			{
				tstatef[ti] = tstate[P[ti]];
			}

			for (int ti = 0; ti < 16; ti++)
			{
				tstate[ti] = tstatef[ti + 16];
			}
			for (int ti = 0; ti < 16; ti++)
			{
				tstatef[ti + 16] = tstate[P[ti + 16] - 16];
			}



			for (int ti = 0; ti < 8; ti++)
			{
				temp = tstatef[ti + 16];
				tstatef[ti + 16] = tstatef[ti + 8];
				tstatef[ti + 8] = temp;
			}


			//交换





			//第一轮做完了

			//此处需要变换差分，对所有有可能的情况进行遍历 j=0表示 所有差分只可能是1357

			//目前的差分是j，对于j差分，再candiffs表里面有描述

			if (j != 0)//第一轮差分都是j
			{//控制变成第几个差分

				//限制输入差分仅限第一个
				//只保留第一列


				for (int i1 = 0; i1 < 16;)//i1表示，第一轮s盒 唯一的哪一个 变成了什么
				{
					//	printf("开始计算第%d位置第一轮从%d到%d的结果（）,目前已经累计的数量为：%llu\n", i, j, candiffs[j][i1], num);

					for (int ti = 0; ti < 32; ti++)
					{
						if (tstatef[ti] != 0)//此处单一变换，需要加权，要把所有情况分别相加
							tstatef[ti] = candiffs[candiffs[j][i1]][0];//全部变成初始值
					}

					/*		for (int ti = 0; ti < 32; ti++)
					{
						printf("%d ", tstatef[ti]);
					}*/

					qian1lingjie[i1] = f1num;


					for (int tti = 0; tti < 16; )//需要便利这32个，有差分就要遍历变换，无差分不管
					{//此刻，所有含差分的差分都仍然是1；
						if (tstatef[tti] == 0)
							tti++;
						else /*if (tstatef[tti] <= 15)*///可以不判断，不是0就操作
						{


							//相当于换了差分了，此处需要操作



							for (int ttti = 0; ttti < 16; ttti++)
							{
								tstate1[ttti] = tstatef[ttti];

							}
							caozuo(tstate1);



							ik = 0;
							jiancha();
							if (ik == 1)
							{
								for (int ttti = 0; ttti < 16; ttti++)
								{
									tstate1[ttti] = tstate[ttti];

								}

								//可以将第一列存起来了

								for (int i1all = 0; i1all < 16; i1all++)
								{
									firstone[(f1num << 4) + i1all] = tstate1[i1all];

								}

								//if (f1num > 600000)
								//	firstone[(f1num << 4) + 1] = tstate1[1];

								f1num++;
							}
							//列混合之后，全扩散就可以了
							if (candiffs[candiffs[j][i1]][tstatef[tti]] != 0)//
								tstatef[tti] = candiffs[candiffs[j][i1]][tstatef[tti]];
							if (candiffs[candiffs[j][i1]][tstatef[tti]] == 0)
							{
								//此刻，需要往后找第一个不是  tstatef[tti]   的，加2，然后前面全部变成0
								int bo = 1;
								int tkind = tti + 1;
								while (bo == 1)
								{
									if ((tstatef[tkind] != 0) & (tstatef[tkind] < tstatef[tti]))
									{

										tstatef[tkind] = candiffs[candiffs[j][i1]][tstatef[tkind]];
										for (int tb = 0; tb < tkind; tb++)
										{
											if (tstatef[tb] != 0)
												tstatef[tb] = candiffs[candiffs[j][i1]][0];
										}
										bo = 0;
										tti = 0;

									}
									else if (tkind == 15)
									{
										bo = 0;
										tti = 16;
									}
									else
									{
										tkind++;
									}
								}
							}
						}
					}
					//num 到此，j差分的第i1个分量处的分差分情况 计算完毕，需要算下一个





					if (candiffs[j][candiffs[j][i1]] != 0)
					{

						i1 = candiffs[j][i1];
						//结束
						/*printf("结束/n");
						fclose(fpWrite);
						exit();*/

					}
					else
					{
						qian1lingjie[candiffs[j][i1]] = f1num;
						i1 = 99;


						/*	printf("第%d个位置的差分为：%d 产生全活跃的概率为%lf %% \n", i, j, (double)num / 0x1000000000000 * 100);*/


							//printf("%lf\n", (double)num/0x1000000000000);
					}



				}
			}



		}
	}


	//printf("【正向】第一列全活跃个数：%llu\n", f1num);
	//存第二列的全扩散差分


	for (int i = input_pos; i < input_pos + 1; i++)//选取含差分的位置
	{
		for (int im = 0; im < 16; im++)
		{
			state1[im] = 0;
			state2[im] = 0;
		}
		for (int im = 0; im < 32; im++)
		{
			statef[im] = 0;

		}
		//该差分变为
		//该位置的差分是j///////////////////////////////////////////////////////////////

		//限制输入差分为1
		for (int j = input_diff; j < input_diff+1; j++)//该输入差分先遍历，，i，j就是最后的结果角标
		{

			num = 0;//一共有12个活跃s盒，第一轮一个，第二轮11个活跃s盒 一个活跃s盒16种可能，就是2^48的数量级，最后的结果要除以这个数
			for (int im = 0; im < 16; im++)
			{
				state1[im] = 0;
				state2[im] = 0;
			}
			for (int im = 0; im < 32; im++)
			{
				statef[im] = 0;

			}



			statef[i] = j;
			if (i < 16)
				state1[i] = j;
			else
			{
				state2[i - 16] = j;
			}
			//sw操作
			int tempsw = 0;
			for (int ti = 0; ti < 8; ti++)
			{
				tempsw = state1[ti + 8];
				state1[ti + 8] = state2[ti];
				state2[ti] = tempsw;


				tempsw = statef[ti + 8];
				statef[ti + 8] = statef[ti + 16];
				statef[ti + 16] = tempsw;
			}


			caozuo(state1);


			//最一开始的初值，f表示初值确定之后的操作
			for (int ti = 0; ti < 16; ti++)
			{
				tstate1[ti] = tstate[ti];
				tstatef[ti] = tstate[ti];

			}

			caozuo(state2);

			for (int ti = 0; ti < 16; ti++)
			{

				tstate2[ti] = tstate[ti];
				tstatef[ti + 16] = tstate[ti];
			}

			int temp;
			ik = 0;
			//交换
			for (int ti = 0; ti < 8; ti++)
			{
				temp = tstatef[ti + 16];
				tstatef[ti + 16] = tstatef[ti + 8];
				tstatef[ti + 8] = temp;
			}

			for (int ti = 0; ti < 16; ti++)
			{
				tstate[ti] = tstatef[ti];
			}
			for (int ti = 0; ti < 16; ti++)
			{
				tstatef[ti] = tstate[P[ti]];
			}

			for (int ti = 0; ti < 16; ti++)
			{
				tstate[ti] = tstatef[ti + 16];
			}
			for (int ti = 0; ti < 16; ti++)
			{
				tstatef[ti + 16] = tstate[P[ti + 16] - 16];
			}


			//交换


			for (int ti = 0; ti < 8; ti++)
			{
				temp = tstatef[ti + 16];
				tstatef[ti + 16] = tstatef[ti + 8];
				tstatef[ti + 8] = temp;
			}


			//第一轮做完了

			//此处需要变换差分，对所有有可能的情况进行遍历 j=0表示 所有差分只可能是1357

			//目前的差分是j，对于j差分，再candiffs表里面有描述

			if (j != 0)//第一轮差分都是j
			{//控制变成第几个差分

				//限制输入差分仅限第一个
				//只保留第一列


				for (int i1 = 0; i1 < 16;)//i1表示，第一轮s盒 唯一的哪一个 变成了什么
				{
					//	printf("开始计算第%d位置第一轮从%d到%d的结果（）,目前已经累计的数量为：%llu\n", i, j, candiffs[j][i1], num);

					for (int ti = 0; ti < 32; ti++)
					{
						if (tstatef[ti] != 0)//此处单一变换，需要加权，要把所有情况分别相加
							tstatef[ti] = candiffs[candiffs[j][i1]][0];//全部变成初始值
					}

					qian2lingjie[i1] = f2num;


					for (int tti = 16; tti < 32; )//需要便利这32个，有差分就要遍历变换，无差分不管
					{//此刻，所有含差分的差分都仍然是1；
						if (tstatef[tti] == 0)
							tti++;
						else /*if (tstatef[tti] <= 15)*///可以不判断，不是0就操作
						{


							//相当于换了差分了，此处需要操作



							for (int ttti = 0; ttti < 16; ttti++)
							{
								tstate1[ttti] = tstatef[ttti + 16];

							}
							caozuo(tstate1);



							ik = 0;
							jiancha();
							if (ik == 1)
							{
								for (int ttti = 0; ttti < 16; ttti++)
								{
									tstate1[ttti] = tstate[ttti];

								}

								//可以将第二列存起来了

								for (int i1all = 0; i1all < 16; i1all++)
								{
									firsttwo[(f2num << 4) + i1all] = tstate1[i1all];

								}

								f2num++;
							}
							//列混合之后，全扩散就可以了
							if (candiffs[candiffs[j][i1]][tstatef[tti]] != 0)//
								tstatef[tti] = candiffs[candiffs[j][i1]][tstatef[tti]];
							if (candiffs[candiffs[j][i1]][tstatef[tti]] == 0)
							{
								//此刻，需要往后找第一个不是  tstatef[tti]   的，加2，然后前面全部变成0
								int bo = 1;
								int tkind = tti + 1;
								while (bo == 1)
								{
									if ((tstatef[tkind] != 0) & (tstatef[tkind] < tstatef[tti]))
									{

										tstatef[tkind] = candiffs[candiffs[j][i1]][tstatef[tkind]];
										for (int tb = 16; tb < tkind; tb++)
										{
											if (tstatef[tb] != 0)
												tstatef[tb] = candiffs[candiffs[j][i1]][0];
										}
										bo = 0;
										tti = 16;

									}
									else if (tkind == 31)
									{
										bo = 0;
										tti = 32;
									}
									else
									{
										tkind++;
									}
								}
							}
						}
					}
					//num 到此，j差分的第i1个分量处的分差分情况 计算完毕，需要算下一个





					if (candiffs[j][candiffs[j][i1]] != 0)
					{

						i1 = candiffs[j][i1];
						//结束
						/*printf("结束/n");
						fclose(fpWrite);
						exit();*/

					}
					else
					{
						qian2lingjie[candiffs[j][i1]] = f2num;
						i1 = 99;


						/*	printf("第%d个位置的差分为：%d 产生全活跃的概率为%lf %% \n", i, j, (double)num / 0x1000000000000 * 100);*/


							//printf("%lf\n", (double)num/0x1000000000000);
					}



				}
			}



		}
	}



	//printf("【正向】第二列全活跃个数：%llu\n", f2num);






#pragma region inversetwo
	for (int i = out_pos; i < out_pos + 1; i++)//选取含差分的位置
	{
		for (int im = 0; im < 16; im++)
		{
			state1[im] = 0;
			state2[im] = 0;
		}
		for (int im = 0; im < 32; im++)
		{
			statef[im] = 0;

		}
		//该差分变为
		//该位置的差分是j///////////////////////////////////////////////////////////////


		unsigned long long oldnum = 1;
		//限制输入差分为1
		for (int j = output_diff; j < output_diff+1; j++)//该输入差分先遍历，，i，j就是最后的结果角标
		{

			num = 0;//一共有12个活跃s盒，第一轮一个，第二轮11个活跃s盒 一个活跃s盒16种可能，就是2^48的数量级，最后的结果要除以这个数
			for (int im = 0; im < 16; im++)
			{
				state1[im] = 0;
				state2[im] = 0;
			}
			for (int im = 0; im < 32; im++)
			{
				statef[im] = 0;

			}



			statef[i] = j;
			if (i < 16)
				state1[i] = j;
			else
			{
				state2[i - 16] = j;
			}
			//sw操作
			int tempsw = 0;
			for (int ti = 0; ti < 8; ti++)
			{
				tempsw = state1[ti + 8];
				state1[ti + 8] = state2[ti];
				state2[ti] = tempsw;


				tempsw = statef[ti + 8];
				statef[ti + 8] = statef[ti + 16];
				statef[ti + 16] = tempsw;
			}


			icaozuo(state1);


			//最一开始的初值，f表示初值确定之后的操作
			for (int ti = 0; ti < 16; ti++)
			{
				tstate1[ti] = tstate[ti];
				tstatef[ti] = tstate[ti];

			}

			icaozuo(state2);

			for (int ti = 0; ti < 16; ti++)
			{

				tstate2[ti] = tstate[ti];
				tstatef[ti + 16] = tstate[ti];
			}

			int temp;
			ik = 0;
			//交换
			for (int ti = 0; ti < 8; ti++)
			{
				temp = tstatef[ti + 16];
				tstatef[ti + 16] = tstatef[ti + 8];
				tstatef[ti + 8] = temp;
			}

			for (int ti = 0; ti < 16; ti++)
			{
				tstate[ti] = tstatef[ti];
			}
			for (int ti = 0; ti < 16; ti++)
			{
				tstatef[ti] = tstate[iP[ti]];
			}

			for (int ti = 0; ti < 16; ti++)
			{
				tstate[ti] = tstatef[ti + 16];
			}
			for (int ti = 0; ti < 16; ti++)
			{
				tstatef[ti + 16] = tstate[iP[ti + 16]];
			}


			//交换


			for (int ti = 0; ti < 8; ti++)
			{
				temp = tstatef[ti + 16];
				tstatef[ti + 16] = tstatef[ti + 8];
				tstatef[ti + 8] = temp;
			}


			//第一轮做完了

			//此处需要变换差分，对所有有可能的情况进行遍历 j=0表示 所有差分只可能是1357

			//目前的差分是j，对于j差分，再candiffs表里面有描述

			if (j != 0)//第一轮差分都是j
			{//控制变成第几个差分

				//限制输入差分仅限第一个

				for (int i1 = 0; i1 < 16;)//i1表示，第一轮s盒 唯一的哪一个 变成了什么
				{

					for (int ti = 0; ti < 16; ti++)
					{
						if (tstatef[ti] != 0)//此处单一变换，需要加权，要把所有情况分别相加
							tstatef[ti] = icandiffs[icandiffs[j][i1]][0];//全部变成初始值
					}

					hou1lingjie[i1] = i1num;




					for (int tti = 0; tti < 16; )//需要便利这32个，有差分就要遍历变换，无差分不管
					{//此刻，所有含差分的差分都仍然是1；
						if (tstatef[tti] == 0)
							tti++;
						else /*if (tstatef[tti] <= 15)*///可以不判断，不是0就操作
						{


							//相当于换了差分了，此处需要操作



							for (int ttti = 0; ttti < 16; ttti++)
							{
								tstate1[ttti] = tstatef[ttti];

							}
							icaozuo(tstate1);



							ik = 0;
							jiancha();
							if (ik == 1)
							{
								for (int ttti = 0; ttti < 16; ttti++)
								{
									tstate1[ttti] = tstate[ttti];

								}

								for (int ttti = 0; ttti < 16; ttti++)
								{
									inverseone[(i1num << 4) + ttti] = tstate1[ttti];

								}
								i1num++;



							}
							//列混合之后，全扩散就可以了
							if (icandiffs[icandiffs[j][i1]][tstatef[tti]] != 0)//
								tstatef[tti] = icandiffs[icandiffs[j][i1]][tstatef[tti]];
							if (icandiffs[icandiffs[j][i1]][tstatef[tti]] == 0)
							{
								//此刻，需要往后找第一个不是  tstatef[tti]   的，加2，然后前面全部变成0
								int bo = 1;
								int tkind = tti + 1;
								while (bo == 1)
								{
									if ((tstatef[tkind] != 0) & (tstatef[tkind] < tstatef[tti]))
									{

										tstatef[tkind] = icandiffs[icandiffs[j][i1]][tstatef[tkind]];
										for (int tb = 0; tb < tkind; tb++)
										{
											if (tstatef[tb] != 0)
												tstatef[tb] = icandiffs[icandiffs[j][i1]][0];
										}
										bo = 0;
										tti = 0;

									}
									else if (tkind == 15)
									{
										bo = 0;
										tti = 16;
									}
									else
									{
										tkind++;
									}
								}
							}
						}
					}
					//num 到此，j差分的第i1个分量处的分差分情况 计算完毕，需要算下一个





					if (icandiffs[j][icandiffs[j][i1]] != 0)
					{

						i1 = icandiffs[j][i1];
						//结束
						/*printf("结束/n");
						fclose(fpWrite);
						exit();*/

					}
					else
					{
						hou1lingjie[icandiffs[j][i1]] = i1num;
						i1 = 99;


						/*	printf("第%d个位置的差分为：%d 产生全活跃的概率为%lf %% \n", i, j, (double)num / 0x1000000000000 * 100);*/


							//printf("%lf\n", (double)num/0x1000000000000);
					}



				}
			}



		}
	}


	//printf("【逆向】第一列全活跃个数：%llu\n", i1num);


	for (int i = out_pos; i < out_pos + 1; i++)//选取含差分的位置
	{
		for (int im = 0; im < 16; im++)
		{
			state1[im] = 0;
			state2[im] = 0;
		}
		for (int im = 0; im < 32; im++)
		{
			statef[im] = 0;

		}
		//该差分变为
		//该位置的差分是j///////////////////////////////////////////////////////////////


		unsigned long long oldnum = 1;
		//限制输入差分为1
		for (int j = output_diff; j < output_diff+1; j++)//该输入差分先遍历，，i，j就是最后的结果角标
		{

			num = 0;//一共有12个活跃s盒，第一轮一个，第二轮11个活跃s盒 一个活跃s盒16种可能，就是2^48的数量级，最后的结果要除以这个数
			for (int im = 0; im < 16; im++)
			{
				state1[im] = 0;
				state2[im] = 0;
			}
			for (int im = 0; im < 32; im++)
			{
				statef[im] = 0;

			}



			statef[i] = j;
			if (i < 16)
				state1[i] = j;
			else
			{
				state2[i - 16] = j;
			}
			//sw操作
			int tempsw = 0;
			for (int ti = 0; ti < 8; ti++)
			{
				tempsw = state1[ti + 8];
				state1[ti + 8] = state2[ti];
				state2[ti] = tempsw;


				tempsw = statef[ti + 8];
				statef[ti + 8] = statef[ti + 16];
				statef[ti + 16] = tempsw;
			}


			icaozuo(state1);


			//最一开始的初值，f表示初值确定之后的操作
			for (int ti = 0; ti < 16; ti++)
			{
				tstate1[ti] = tstate[ti];
				tstatef[ti] = tstate[ti];

			}

			icaozuo(state2);

			for (int ti = 0; ti < 16; ti++)
			{

				tstate2[ti] = tstate[ti];
				tstatef[ti + 16] = tstate[ti];
			}

			int temp;
			ik = 0;
			//交换
			for (int ti = 0; ti < 8; ti++)
			{
				temp = tstatef[ti + 16];
				tstatef[ti + 16] = tstatef[ti + 8];
				tstatef[ti + 8] = temp;
			}

			for (int ti = 0; ti < 16; ti++)
			{
				tstate[ti] = tstatef[ti];
			}
			for (int ti = 0; ti < 16; ti++)
			{
				tstatef[ti] = tstate[iP[ti]];
			}

			for (int ti = 0; ti < 16; ti++)
			{
				tstate[ti] = tstatef[ti + 16];
			}
			for (int ti = 0; ti < 16; ti++)
			{
				tstatef[ti + 16] = tstate[iP[ti + 16]];
			}


			//交换


			for (int ti = 0; ti < 8; ti++)
			{
				temp = tstatef[ti + 16];
				tstatef[ti + 16] = tstatef[ti + 8];
				tstatef[ti + 8] = temp;
			}


			//第一轮做完了

			//此处需要变换差分，对所有有可能的情况进行遍历 j=0表示 所有差分只可能是1357

			//目前的差分是j，对于j差分，再candiffs表里面有描述

			if (j != 0)//第一轮差分都是j
			{//控制变成第几个差分

				//限制输入差分仅限第一个

				for (int i1 = 0; i1 < 16;)//i1表示，第一轮s盒 唯一的哪一个 变成了什么
				{

					for (int ti = 16; ti < 32; ti++)
					{
						if (tstatef[ti] != 0)//此处单一变换，需要加权，要把所有情况分别相加
							tstatef[ti] = icandiffs[icandiffs[j][i1]][0];//全部变成初始值
					}

					hou2lingjie[i1] = i2num;




					for (int tti = 16; tti < 32; )//需要便利这32个，有差分就要遍历变换，无差分不管
					{//此刻，所有含差分的差分都仍然是1；
						if (tstatef[tti] == 0)
							tti++;
						else /*if (tstatef[tti] <= 15)*///可以不判断，不是0就操作
						{


							//相当于换了差分了，此处需要操作



							for (int ttti = 0; ttti < 16; ttti++)
							{
								tstate1[ttti] = tstatef[ttti + 16];

							}
							icaozuo(tstate1);



							ik = 0;
							jiancha();
							if (ik == 1)
							{
								for (int ttti = 0; ttti < 16; ttti++)
								{
									tstate1[ttti] = tstate[ttti];

								}

								for (int ttti = 0; ttti < 16; ttti++)
								{
									inversetwo[(i2num << 4) + ttti] = tstate1[ttti];

								}
								i2num++;



							}
							//列混合之后，全扩散就可以了
							if (icandiffs[icandiffs[j][i1]][tstatef[tti]] != 0)//
								tstatef[tti] = icandiffs[icandiffs[j][i1]][tstatef[tti]];
							if (icandiffs[icandiffs[j][i1]][tstatef[tti]] == 0)
							{
								//此刻，需要往后找第一个不是  tstatef[tti]   的，加2，然后前面全部变成0
								int bo = 1;
								int tkind = tti + 1;
								while (bo == 1)
								{
									if ((tstatef[tkind] != 0) & (tstatef[tkind] < tstatef[tti]))
									{

										tstatef[tkind] = icandiffs[icandiffs[j][i1]][tstatef[tkind]];
										for (int tb = 16; tb < tkind; tb++)
										{
											if (tstatef[tb] != 0)
												tstatef[tb] = icandiffs[icandiffs[j][i1]][0];
										}
										bo = 0;
										tti = 16;

									}
									else if (tkind == 31)
									{
										bo = 0;
										tti = 32;
									}
									else
									{
										tkind++;
									}
								}
							}
						}
					}
					//num 到此，j差分的第i1个分量处的分差分情况 计算完毕，需要算下一个





					if (icandiffs[j][icandiffs[j][i1]] != 0)
					{

						i1 = icandiffs[j][i1];
						//结束
						/*printf("结束/n");
						fclose(fpWrite);
						exit();*/

					}
					else
					{
						hou2lingjie[icandiffs[j][i1]] = i2num;
						i1 = 99;


						/*	printf("第%d个位置的差分为：%d 产生全活跃的概率为%lf %% \n", i, j, (double)num / 0x1000000000000 * 100);*/


							//printf("%lf\n", (double)num/0x1000000000000);
					}



				}
			}



		}
	}

	//printf("【逆向】第二列全活跃个数：%llu\n", i2num);
#pragma endregion















	//for (int i = 0; i < 16; i++)
	//{
	//	printf("%llu ", qian1lingjie[i]);
	//}
	//printf("\n");


	//for (int i = 0; i < 16; i++)
	//{
	//	printf("%llu ", qian2lingjie[i]);
	//}

	//printf("\n");



	//for (int i = 0; i < 16; i++)
	//{
	//	printf("%llu ", hou1lingjie[i]);
	//}
	//printf("\n");


	//for (int i = 0; i < 16; i++)
	//{
	//	printf("%llu ", hou2lingjie[i]);
	//}




	for (int i = 0; i < i1num; i++)
	{
		part32inverseone[(i << 4) + 0] = inverseone[(i << 4)];
		part32inverseone[(i << 4) + 1] = inverseone[(i << 4) + 1];
		part32inverseone[(i << 4) + 2] = inverseone[(i << 4) + 2];
		part32inverseone[(i << 4) + 3] = inverseone[(i << 4) + 3];
		part32inverseone[(i << 4) + 4] = inverseone[(i << 4) + 14];
		part32inverseone[(i << 4) + 5] = inverseone[(i << 4) + 15];
		part32inverseone[(i << 4) + 6] = inverseone[(i << 4) + 8];
		part32inverseone[(i << 4) + 7] = inverseone[(i << 4) + 9];
		//和第二列比
		part32inverseone[(i << 4) + 8] = inverseone[(i << 4) + 4];
		part32inverseone[(i << 4) + 9] = inverseone[(i << 4) + 5];
		part32inverseone[(i << 4) + 10] = inverseone[(i << 4) + 6];
		part32inverseone[(i << 4) + 11] = inverseone[(i << 4) + 7];
		part32inverseone[(i << 4) + 12] = inverseone[(i << 4) + 12];
		part32inverseone[(i << 4) + 13] = inverseone[(i << 4) + 13];
		part32inverseone[(i << 4) + 14] = inverseone[(i << 4) + 10];
		part32inverseone[(i << 4) + 15] = inverseone[(i << 4) + 11];





	}

	for (int i = 0; i < i2num; i++)
	{
		part32inversetwo[(i << 4) + 0] = inversetwo[(i << 4) + 16 - 16];
		part32inversetwo[(i << 4) + 1] = inversetwo[(i << 4) + 17 - 16];
		part32inversetwo[(i << 4) + 2] = inversetwo[(i << 4) + 18 - 16];
		part32inversetwo[(i << 4) + 3] = inversetwo[(i << 4) + 19 - 16];
		part32inversetwo[(i << 4) + 4] = inversetwo[(i << 4) + 24 - 16];
		part32inversetwo[(i << 4) + 5] = inversetwo[(i << 4) + 25 - 16];
		part32inversetwo[(i << 4) + 6] = inversetwo[(i << 4) + 30 - 16];
		part32inversetwo[(i << 4) + 7] = inversetwo[(i << 4) + 31 - 16];
		//和第二列比
		part32inversetwo[(i << 4) + 8] = inversetwo[(i << 4) + 22 - 16];
		part32inversetwo[(i << 4) + 9] = inversetwo[(i << 4) + 23 - 16];
		part32inversetwo[(i << 4) + 10] = inversetwo[(i << 4) + 20 - 16];
		part32inversetwo[(i << 4) + 11] = inversetwo[(i << 4) + 21 - 16];
		part32inversetwo[(i << 4) + 12] = inversetwo[(i << 4) + 28 - 16];
		part32inversetwo[(i << 4) + 13] = inversetwo[(i << 4) + 29 - 16];
		part32inversetwo[(i << 4) + 14] = inversetwo[(i << 4) + 26 - 16];
		part32inversetwo[(i << 4) + 15] = inversetwo[(i << 4) + 27 - 16];





	}

	for (int i = 0; i < f1num; i++)
	{
		half161firstone[(i << 4)] = firstone[(i << 4) + 2];
		half161firstone[(i << 4) + 1] = firstone[(i << 4) + 3];
		half161firstone[(i << 4) + 2] = firstone[(i << 4) + 6];
		half161firstone[(i << 4) + 3] = firstone[(i << 4) + 7];
		half161firstone[(i << 4) + 4] = firstone[(i << 4) + 8];
		half161firstone[(i << 4) + 5] = firstone[(i << 4) + 9];
		half161firstone[(i << 4) + 6] = firstone[(i << 4) + 12];
		half161firstone[(i << 4) + 7] = firstone[(i << 4) + 13];
		//和β第二列比
		half161firstone[(i << 4) + 8] = firstone[(i << 4) + 0];
		half161firstone[(i << 4) + 9] = firstone[(i << 4) + 1];
		half161firstone[(i << 4) + 10] = firstone[(i << 4) + 4];
		half161firstone[(i << 4) + 11] = firstone[(i << 4) + 5];
		half161firstone[(i << 4) + 12] = firstone[(i << 4) + 10];
		half161firstone[(i << 4) + 13] = firstone[(i << 4) + 11];
		half161firstone[(i << 4) + 14] = firstone[(i << 4) + 14];
		half161firstone[(i << 4) + 15] = firstone[(i << 4) + 15];

	}

	//假设β1在前
	for (int i = 0; i < f2num; i++)
	{
		half161firsttwo[(i << 4)] = firsttwo[(i << 4) + 0];
		half161firsttwo[(i << 4) + 1] = firsttwo[(i << 4) + 1];
		half161firsttwo[(i << 4) + 2] = firsttwo[(i << 4) + 4];
		half161firsttwo[(i << 4) + 3] = firsttwo[(i << 4) + 5];
		half161firsttwo[(i << 4) + 4] = firsttwo[(i << 4) + 10];
		half161firsttwo[(i << 4) + 5] = firsttwo[(i << 4) + 11];
		half161firsttwo[(i << 4) + 6] = firsttwo[(i << 4) + 14];
		half161firsttwo[(i << 4) + 7] = firsttwo[(i << 4) + 15];
		//和β第二列比
		half161firsttwo[(i << 4) + 8] = firsttwo[(i << 4) + 2];
		half161firsttwo[(i << 4) + 9] = firsttwo[(i << 4) + 3];
		half161firsttwo[(i << 4) + 10] = firsttwo[(i << 4) + 6];
		half161firsttwo[(i << 4) + 11] = firsttwo[(i << 4) + 7];
		half161firsttwo[(i << 4) + 12] = firsttwo[(i << 4) + 8];
		half161firsttwo[(i << 4) + 13] = firsttwo[(i << 4) + 9];
		half161firsttwo[(i << 4) + 14] = firsttwo[(i << 4) + 12];
		half161firsttwo[(i << 4) + 15] = firsttwo[(i << 4) + 13];

	}


	tempindex = 0;
	for (int i = 0; i < 16; )
	{
		if(qian1lingjie[candiffs[diffalpha][i]] - 1> qian1lingjie[tempindex])
		quicksort(qian1lingjie[tempindex], qian1lingjie[candiffs[diffalpha][i]] - 1, half161firstone);
		/*	printf("111\n");*/
		tempindex = candiffs[diffalpha][i];
		i = candiffs[diffalpha][i];
		if (candiffs[diffalpha][i] == 0)
		{
			i = 16;
			tempindex = 0;
		}
	}

	for (int i = 0; i < 16; )
	{
		if (qian2lingjie[candiffs[diffalpha][i]] - 1 > qian2lingjie[tempindex])
		quicksort(qian2lingjie[tempindex], qian2lingjie[candiffs[diffalpha][i]] - 1, half161firsttwo);
		/*	printf("111\n");*/
		tempindex = candiffs[diffalpha][i];
		i = candiffs[diffalpha][i];
		if (candiffs[diffalpha][i] == 0)
		{
			i = 16;
			tempindex = 0;
		}
	}
	for (int i = 0; i < 16; )
	{
		if (hou1lingjie[icandiffs[diffbeita][i]] - 1 > hou1lingjie[tempindex])
		quicksort(hou1lingjie[tempindex], hou1lingjie[icandiffs[diffbeita][i]] - 1, part32inverseone);
		/*	printf("111\n");*/
		tempindex = icandiffs[diffbeita][i];
		i = icandiffs[diffbeita][i];
		if (icandiffs[diffbeita][i] == 0)
		{
			i = 16;
			tempindex = 0;
		}
	}

	for (int i = 0; i < 16; )
	{
		if (hou2lingjie[icandiffs[diffbeita][i]] - 1 > hou2lingjie[tempindex])
		quicksort(hou2lingjie[tempindex], hou2lingjie[icandiffs[diffbeita][i]] - 1, part32inversetwo);
		/*	printf("111\n");*/
		tempindex = icandiffs[diffbeita][i];
		i = icandiffs[diffbeita][i];
		if (icandiffs[diffbeita][i] == 0)
		{
			i = 16;
			tempindex = 0;
		}
	}


	//printf("\n【双向】最密堆积方法的α和β已经组装并排列完毕！\n");

//	end = clock();
	//printf("\n截至目前所耗时：%lf秒\n", ((double)(end - start)) / CLOCKS_PER_SEC);


	//printf("\n现在开始计算碰撞\n");

	for (size_t i = 0; i < i1num; i++)
	{

		if (NOW_ISTIME_CLOSE == 1)
		{
			i = i1num;

			printf("输入位置：%d输出位置：%d存在差分路径  差分对为：%d  %d\n", input_pos, out_pos,input_diff,output_diff);
			return 0;
		}
		currentbeta = i;
		Select_First_Step(i, 0, candiffs[input_diff][0]);



	}

	//end = clock();
	if (NOW_ISTIME_CLOSE != 1)
	printf("输入位置：%d输出位置：%d不存在差分路径  差分对为：%d  %d\n", input_pos, out_pos, input_diff, output_diff);
	else
	{
		printf("输入位置：%d输出位置：%d存在差分路径  差分对为：%d  %d\n", input_pos, out_pos, input_diff, output_diff);
	}
	exit(0);







}










int main()
{
	NOW_ISTIME_CLOSE = 0;

	start = clock();


	//空间分配，最后释放。
	firstone = (char*)malloc(80000000);
	firsttwo = (char*)malloc(80000000);
	inverseone = (char*)malloc(80000000);
	inversetwo = (char*)malloc(80000000);

	half161firstone = (char*)malloc(80000000);
	//	half162firstone = (char*)malloc(5000000);
		//12合起来是完整的，因此12分开的时候不可以排序


	half161firsttwo = (char*)malloc(80000000);
	//half162firsttwo = (char*)malloc(5000000);

	part32inverseone = (char*)malloc(80000000);
	part32inversetwo = (char*)malloc(80000000);

	//num = 0;




	if (part32inversetwo)
		printf("内存分配成功!\n");
	else
	{
		printf("内存分配失败!\n");
		exit(0);
	}

	for (size_t i = 0; i < 32; i++)
	{
		for (size_t j = 0; j < 32; j++)
		{
			for (size_t k = 1; k < 16; k++)
			{

				for (size_t l = 1; l < 16; l++)
				{
					NOW_ISTIME_CLOSE = 0;
					pos_select(i, j,k,l);
				}

			}


			
		}
	}






	/*printf("\n匹配到的α1上半部数量：%llu\n", can_go_alpha);


	printf("\n匹配到的β2上半部数量：%llu\n", can_go_beta2);




	printf("\n碰撞总数：%ld\n", imposs_num);*/
	//最后释放内存

	free(firstone);
	free(firsttwo);
	free(inverseone);
	free(inversetwo);


	free(part32inverseone);
	free(part32inversetwo);
	free(half161firstone);
	free(half161firsttwo);

	printf("\n释放内存成功\n");

	return 1008611;
}
